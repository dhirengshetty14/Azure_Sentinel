# Azure Sentinel: A Cloud-Native Real-Time Log Analytics Platform

Azure Sentinel is an end-to-end platform engineered to provide instantaneous insights into application health by ingesting, processing, and visualizing log data in real-time. This project demonstrates a scalable, event-driven architecture built entirely on the Microsoft Azure ecosystem, showcasing best practices in cloud-native development.

## Project Vision

The goal of this project was to build a monitoring solution that could handle the high volume and velocity of data generated by microservices without sacrificing performance. In a production environment, identifying a critical error seconds faster can make all the difference. This platform is designed to turn a flood of raw log data into a clear, actionable, and live picture of system behavior.

## Core Features

* **High-Throughput Ingestion**: A resilient .NET API endpoint capable of handling a high volume of concurrent log submissions.
* **Real-Time Dashboard**: A Blazor WebAssembly single-page application that displays logs the moment they are processed, with no need for manual refreshes.
* **Interactive UI**: A clean user interface that allows developers to filter the live stream by log severity (Error, Warning, Info) to quickly isolate important events.
* **AI-Powered Insights**: Integrated with Azure AI services to perform sentiment analysis on error logs, helping to prioritize the most critical user-impacting issues.
* **System Resilience**: The ingestion API is protected with rate limiting to prevent system overloads and ensure stability.
* **Automated Infrastructure**: The entire cloud environment is defined declaratively using Bicep (Infrastructure as Code) for automated, consistent, and repeatable deployments.

## Architecture Deep Dive

The platform is built on a decoupled, event-driven architecture to ensure each component can scale independently.



1.  **Ingestion Layer**: The entry point is a high-performance **.NET 8 Web API**. It validates incoming data and is secured with rate limiting.
2.  **Processing & Persistence**: The API hands off the log entry to a dedicated service layer. This layer simultaneously persists the log to **Azure Cosmos DB** (chosen for its low-latency writes and flexible schema) and prepares it for real-time distribution.
3.  **Real-Time Backplane**: **Azure SignalR Service** acts as the messaging backplane, allowing the API to push updates to thousands of connected clients with sub-second latency.
4.  **Frontend Visualization**: The **Blazor WebAssembly** dashboard establishes a persistent connection to the SignalR service. It receives new log entries as they happen and dynamically updates the UI.
5.  **Observability & Monitoring**: **Azure Application Insights** is deeply integrated into the API, providing rich performance metrics, dependency tracking, and distributed tracing.

## Technology Stack

* **Languages & Frameworks**: C#, .NET 8, ASP.NET Core, Blazor WebAssembly
* **Azure Cloud Services**: App Service, Cosmos DB, SignalR Service, Application Insights, Azure AI Language
* **DevOps & Automation**: Bicep (Infrastructure as Code), Git, GitHub Actions
* **Testing**: xUnit, Moq

## Setup and Deployment

1.  **Prerequisites**:
    * .NET 8 SDK
    * Azure CLI
    * An active Azure subscription
2.  **Clone the Repository**:
    ```bash
    git clone https://github.com/dhirengshetty14/Azure_Sentinel.git
    cd Azure_Sentinel
    ```
3.  **Deploy Azure Infrastructure**:
    * Navigate to the `deployment` folder.
    * Run the main Bicep file to create all necessary Azure resources:
        ```bash
        az deployment group create --resource-group (give a name) --template-file main.bicep
        ```
4.  **Configure Application Secrets**:
    * Update the `appsettings.json` file in the `LogIngestor.API` project with the connection strings from your newly deployed Azure resources.
5.  **Run Locally**:
    * Open the solution in your preferred IDE.
    * Run both the `LogIngestor.API` and `Dashboard.WebApp` projects.
